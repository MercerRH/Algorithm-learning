# 题目描述：
#     将 M 个同样的苹果放在 N 个同样的盘子里，允许有的盘子空着不放，问有多少种不同的分法？注意 1 5 1 与 1 1 5 是同一种分法
# 输入：
#     M N 两个整数，M >= 1, N <= 10
# 样例输入：
#     7 3
# 样例输出：
#     8


# 代码
def solve(M, N):
    """
    用于求 M 个苹果放在 N 个完全相同的盘子中的摆放方法总数

    思路：
        a. 初始状态：M 个苹果，N 个盘子
        b. 状态分类：
            1. M < N：则可认为是将 M 个苹果放在 M 个盘子中，因为多出来的盘子完全一样
            2. M >= N：此时有两种放法
                (1) 至少一个盘子为空的放置方法
                (2) 全部盘子都不为空的放置方法
                我们可以得出下面的公式：
                    所有放置方法 = 至少一个盘子为空的放置方法 + 所有盘子都不为空的放置方法
                在递归时，我们可以认为至少一个盘子为空代表一个盘子为空，因为两个盘子为空的情况会在下一次递归中只有一个盘子为空的情况中出现。
        c. 结束条件：M == 0 即没有苹果时，此时只有一种放法即不放，返回 1；N == 0 即没有盘子时说明放法错误，返回 0
            为什么结束条件为 M/N 均为 0 呢？
            我们看代码：return solve(M, N-1) + solve(M-N, N)
                其中 N 是每次减 1，所以必定会到 0；而 M < N 的情况在先前的判断语句中已经替换为了两个 M，因此 M 的值（即上一次递归中的 M - N）大于等于 0

    :param M: 整数，表示苹果的个数
    :param N: 整数，表示盘子的个数
    :return: 整数，表示放法
    """
    if M < N:  # 若盘子数多于苹果数则减去多余的盘子
        return solve(M, M)
    else:
        if M == 0:  # 若没有苹果则返回 1
            return 1
        elif N == 0:
            return 0
        else:
            return solve(M, N-1) + solve(M-N, N)  # 总放法 = 至少一个盘子为空的放法 + 所有盘子都不空的放法

if __name__ == "__main__":
    print(solve(7, 3))